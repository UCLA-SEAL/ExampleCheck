results[https://github.com/hazelcast/hazelcast/blob/f41222cbac23b683a67e1a07d1343c045ad634bb/hazelcast/src/main/java/com/hazelcast/ascii/memcache/IncrementCommand.java][writeTo][5] = -> LOOP { -> destination.put(response.get(),)@destination.hasRemaining()&&response.hasRemaining() } -> return !(response.hasRemaining())@
results[https://github.com/disy/jSCSI/blob/7dc545a6574be01137cb7b88d24a4282e10282ac/jSCSI-deprecated/src/org/jscsi/parser/datasegment/AbstractDataSegment.java][setDataBuffer][2] = -> src.position(off,)@ -> LOOP { -> dataBuffer.put(src.get(),)@src.hasRemaining()&&++n<length } -> dataBuffer.rewind()@
results[https://github.com/apache/httpcore/blob/99baa92d9a03ea2609f74a640ed5bcb47112dfa6/module-nio/src/test/java/org/apache/http/nio/mockup/ReadableByteChannelMockup.java][read][9] = -> TRY {  -> LOOP { -> dst.put(this.currentChunk.get(),)@dst.hasRemaining()&&this.currentChunk.hasRemaining() } } CATCH(IOException) {}
results[https://github.com/hazelcast/hazelcast/blob/f963f01955d48c55538ee86b08004a22232a050b/hazelcast/src/main/java/com/hazelcast/ascii/memcache/SetCommand.java][writeTo][5] = -> IF { -> response=ByteBuffer.wrap(STORED,)@response==null } -> LOOP { -> bb.put(response.get(),)@bb.hasRemaining()&&response.hasRemaining() } -> return !(response.hasRemaining())@
results[https://github.com/http-kit/http-kit/blob/c9c0b155a4ab05630d332a7d2da0aaf433889772/src/java/org/httpkit/server/WSDecoder.java][isAvailable][1] = -> LOOP { -> IF { -> tmpBuffer.put(src.get(),)@src.hasRemaining() && tmpBuffer.position()<length } ELSE { -> return false@!(src.hasRemaining()) && tmpBuffer.position()<length } } -> tmpBuffer.flip()@!(tmpBuffer.position()<length)
results[https://github.com/ybrs/hazelcastforked/blob/6d494fa5ef514816a415adb7e2e13314d67bbf87/hazelcast/src/main/java/com/hazelcast/impl/ascii/rest/HttpPostCommand.java][readLine][2] = -> LOOP { -> b=cb.get()@cb.hasRemaining() -> c=(char) b@!(cb.hasRemaining()) -> IF { -> return true@cb.hasRemaining() && c=='\n' } ELSE { -> IF { -> line.put(b,)@!(cb.hasRemaining()) && !(c=='\n') } } }
results[https://github.com/MinecraftForge/FML/blob/8844554da6d5d15756d7b0a9da2f5924006b3190/common/cpw/mods/fml/repackage/com/nothome/delta/ByteBufferSeekableSource.java][read][2] = -> TRY {  -> IF { -> return -1@!(cur.hasRemaining()) } -> LOOP { -> dest.put(cur.get(),)@cur.hasRemaining()&&dest.hasRemaining() && !(!(cur.hasRemaining())) } } CATCH(IOException) {}
results[https://github.com/teiid/teiid/blob/180dbded03a3b8f71b9340aa76f7d6fed9eae93e/engine/src/main/java/org/teiid/query/function/CharsetUtils.java][decodeLoop][1] = -> LOOP { -> bb.put(in.get(),)@in.hasRemaining() -> IF { -> IF { -> return CoderResult.OVERFLOW@in.hasRemaining() && !(bb.hasRemaining()) } -> bb.flip()@!(in.hasRemaining()) && !(bb.hasRemaining()) -> bb.clear()@!(in.hasRemaining()) && !(bb.hasRemaining()) } }
results[https://github.com/disy/jSCSI/blob/7dc545a6574be01137cb7b88d24a4282e10282ac/jSCSI-deprecated/src/org/jscsi/parser/datasegment/BinaryDataSegment.java][transferBytes][2] = -> IF { -> throw new IllegalArgumentException("The given length must be less or equal than the remaining bytes in the destination buffer.",)@dst.remaining()<len } -> LOOP { -> IF { -> dst.put(src.get(),)@!(dst.remaining()<len) && !(i<len) && src.hasRemaining()&&dst.hasRemaining() } ELSE { -> throw new RuntimeException("Error by transferring the bytes in this data segment.",)@!(dst.remaining()<len) && i<len && !(src.hasRemaining()&&dst.hasRemaining()) } }
results[https://github.com/GrizzlyNIO/grizzly-mirror/blob/7a200042cae8756d47cb9a7f0702b403efebc565/modules/http/src/main/java/org/glassfish/grizzly/http/util/B2CConverter.java][flushRemainder][1] = -> LOOP { -> remainder.put(tmp_bb.get(),)@remainder.position()>0&&tmp_bb.hasRemaining() -> remainder.flip()@remainder.position()>0&&tmp_bb.hasRemaining() -> cr=decoder.decode(remainder,tmp_cb,false,)@remainder.position()>0&&tmp_bb.hasRemaining() -> IF { -> throw new IllegalStateException("CharChunk is not big enough",)@cr==CoderResult.OVERFLOW && remainder.position()>0&&tmp_bb.hasRemaining() } -> IF { -> remainder.clear()@!(cr==CoderResult.OVERFLOW) && !(remainder.hasRemaining()) && remainder.position()>0&&tmp_bb.hasRemaining() } -> remainder.compact()@!(cr==CoderResult.OVERFLOW) && remainder.position()>0&&tmp_bb.hasRemaining() }
results[https://github.com/sigmarkarl/world/blob/4fc8f09bd8c98be19a05f3bed4ff0e6f33406f2d/javafasta/src/org/java_websocket/drafts/Draft.java][readLine][17] = -> sbuf=ByteBuffer.allocate(buf.remaining(),)@ -> LOOP { -> cur=buf.get()@buf.hasRemaining() -> sbuf.put(cur,)@!(buf.hasRemaining()) -> IF { -> sbuf.limit(sbuf.position()-2,)@!(prev==(byte) '\r'&&cur==(byte) '\n') && !(buf.hasRemaining()) -> sbuf.position(0,)@!(prev==(byte) '\r'&&cur==(byte) '\n') && !(buf.hasRemaining()) -> return sbuf@buf.hasRemaining() && prev==(byte) '\r'&&cur==(byte) '\n' } } -> buf.position(buf.position()-sbuf.position(),)@!(buf.hasRemaining())
results[https://github.com/disy/jSCSI/blob/c5550dbb7fa9389f6f1afb355597ba3a2978307f/bundles/initiator/src/main/java/org/jscsi/initiator/connection/state/ReadResponseState.java][readHandleImmediateData][1] = -> TRY {  -> dataSegment=protocolDataUnit.getDataSegment()@ -> LOOP { -> buffer.put(dataSegment.get(),)@buffer.hasRemaining()&&dataSegment.hasRemaining() } -> IF { -> return @parser.getStatus()==SCSIStatus.GOOD } ELSE { -> throw new InternetSCSIException()@!(parser.getStatus()==SCSIStatus.GOOD) } } CATCH(InternetSCSIException) {}
results[https://github.com/pagxir/antalk/blob/c0ed7ca00bd71f66ee60d3df7b28742d46f8f952/src/com/zhuri/ssl/SSLChannel.java][read][3] = -> TRY {  -> IF { -> IF { -> return appBytesProduced@appBytesProduced==-1||appBytesProduced==0 && !(peerAppData.hasRemaining()) } } -> limit=Math.min(peerAppData.remaining(),dst.remaining(),)@!(!(peerAppData.hasRemaining())) -> LOOP { -> dst.put(peerAppData.get(),)@!(!(peerAppData.hasRemaining())) } } CATCH(IOException) {}
results[https://github.com/disy/jSCSI/blob/7dc545a6574be01137cb7b88d24a4282e10282ac/jSCSI-deprecated/src/org/jscsi/parser/datasegment/AbstractDataSegment.java][next][2] = -> IF { -> throw new IllegalArgumentException()@chunkSize<0&&chunkSize>maxChunkSize } -> pos=dataBuffer.position()@!(chunkSize<0&&chunkSize>maxChunkSize) -> dataBuffer.position(cursor,)@!(chunkSize<0&&chunkSize>maxChunkSize) -> data.position(0,).limit(chunkSize,)@!(chunkSize<0&&chunkSize>maxChunkSize) -> LOOP { -> data.put(dataBuffer.get(),)@data.hasRemaining()&&dataBuffer.hasRemaining() && !(chunkSize<0&&chunkSize>maxChunkSize) } -> dataSegmentLength=data.position()@!(chunkSize<0&&chunkSize>maxChunkSize) -> data.limit(totalLength,)@!(chunkSize<0&&chunkSize>maxChunkSize) -> data.rewind()@!(chunkSize<0&&chunkSize>maxChunkSize) -> dataBuffer.position(pos,)@!(chunkSize<0&&chunkSize>maxChunkSize)
results[https://github.com/FoxyCorndog/WorkspaceOld/blob/495cbdb832ea4148e04db196e2c185b5b7e49fee/gafggfds/slick/src/org/newdawn/slick/openal/WaveData.java][convertAudioBytes][30] = -> dest=ByteBuffer.allocateDirect(audio_bytes.length,)@ -> dest.order(ByteOrder.nativeOrder(),)@ -> src=ByteBuffer.wrap(audio_bytes,)@ -> src.order(ByteOrder.LITTLE_ENDIAN,)@ -> IF { -> dest_short=dest.asShortBuffer()@ -> src_short=src.asShortBuffer()@ } ELSE { -> LOOP { -> dest.put(src.get(),)@src.hasRemaining() } } -> dest.rewind()@
results[https://github.com/hazelcast/hazelcast/blob/4a923f283aa641f947eed63633e1e584bf570090/hazelcast/src/main/java/com/hazelcast/nio/ascii/SocketTextReader.java][doRead][1] = -> LOOP { -> b=bb.get()@!(commandLineRead)&&bb.hasRemaining() -> c=(char) b@ } ELSE { -> IF { -> commandLine.put(b,)@ } } -> IF { -> IF { -> processCmd(toStringAndClear(commandLine,),)@ } -> IF { -> complete=command.readFrom(bb,)@command!=null } }
results[https://github.com/ybrs/hazelcastforked/blob/6d494fa5ef514816a415adb7e2e13314d67bbf87/hazelcast/src/main/java/com/hazelcast/nio/ascii/SocketTextReader.java][doRead][1] = -> LOOP { -> b=bb.get()@!(commandLineRead)&&bb.hasRemaining() -> c=(char) b@ } ELSE { -> IF { -> commandLine.put(b,)@ } } -> IF { -> IF { -> processCmd(toStringAndClear(commandLine,),)@ } -> IF { -> complete=command.doRead(bb,)@command!=null } }
results[https://github.com/void256/nifty-gui/blob/5cbd8e893928b49ebc29a0e7aa2e6732e63f5cc3/src/main/java/de/lessvoid/nifty/sound/openal/slick/AiffData.java][convertAudioBytes][20] = -> dest=ByteBuffer.allocateDirect(audio_bytes.length,)@ -> dest.order(ByteOrder.nativeOrder(),)@ -> src=ByteBuffer.wrap(audio_bytes,)@ -> src.order(ByteOrder.BIG_ENDIAN,)@ -> IF { -> dest_short=dest.asShortBuffer()@ -> src_short=src.asShortBuffer()@ } ELSE { -> LOOP { -> b=src.get()@src.hasRemaining() -> IF { -> b=(byte) b+127@ } -> dest.put(b,)@ } } -> dest.rewind()@
results[https://github.com/metamx/druid/blob/50b6888210c432304730459731bb749ff52230f3/processing/src/main/java/io/druid/query/aggregation/hyperloglog/HyperLogLogCollector.java][convertToDenseStorage][1] = -> tmpBuffer=ByteBuffer.allocateDirect(getNumBytesForDenseStorage(),)@ -> setVersion(tmpBuffer,)@ -> setRegisterOffset(tmpBuffer,getRegisterOffset(),)@ -> setNumNonZeroRegisters(tmpBuffer,getNumNonZeroRegisters(),)@ -> setMaxOverflowValue(tmpBuffer,getMaxOverflowValue(),)@ -> setMaxOverflowRegister(tmpBuffer,getMaxOverflowRegister(),)@ -> storageBuffer.position(getPayloadBytePosition(),)@ -> tmpBuffer.position(getPayloadBytePosition(tmpBuffer,),)@ -> LOOP { -> tmpBuffer.put(storageBuffer.getShort(),storageBuffer.get(),)@storageBuffer.hasRemaining() } -> tmpBuffer.rewind()@
results[https://github.com/hxzon/java-lib-hxzon/blob/ba161a9baa38c5e6c049557fb7be97745d192917/code/java/java nio/nioserver-2008-02-03/src/java/org/ronsoft/nioserver/impl/InputQueueImpl.java][dequeueBytes][1] = -> IF { -> return emptyBuffer@buffer==null||buffer.position()==0||count==0 } -> size=Math.min(count,buffer.position(),)@!(buffer==null||buffer.position()==0||count==0) -> result=ByteBuffer.allocate(size,)@!(buffer==null||buffer.position()==0||count==0) -> buffer.flip()@!(buffer==null||buffer.position()==0||count==0) -> IF { -> result.put(buffer,)@buffer.remaining()<=result.remaining() && !(buffer==null||buffer.position()==0||count==0) } ELSE { -> LOOP { -> result.put(buffer.get(),)@!(buffer.remaining()<=result.remaining()) && !(buffer==null||buffer.position()==0||count==0) && result.hasRemaining() } } -> IF { -> bufferFactory.returnBuffer(buffer,)@!(buffer==null||buffer.position()==0||count==0) && buffer.remaining()==0 } ELSE { -> buffer.compact()@!(buffer.remaining()==0) && !(buffer==null||buffer.position()==0||count==0) } -> result.flip()@!(buffer==null||buffer.position()==0||count==0)
results[https://github.com/spring-projects/spring-integration/blob/233994116c103f618c2b00ddab8965b8af423c97/org.springframework.integration.ip/src/main/java/org/springframework/integration/ip/tcp/NioSocketReader.java][assembleDataCrLfFormat][2] = -> TRY {  -> IF { -> LOOP { -> IF { -> return false@!(rawBuffer.hasRemaining()) } -> bite=rawBuffer.get()@!(!(rawBuffer.hasRemaining())) -> IF { -> buildBuffer.position(buildBuffer.position()-1,)@!(!(rawBuffer.hasRemaining())) && bite=='\n'&&buildBuffer.position()>0 -> IF { -> buildBuffer.position(buildBuffer.position()-1,)@buildBuffer.get()=='\r' && !(!(rawBuffer.hasRemaining())) && bite=='\n'&&buildBuffer.position()>0 } } -> buildBuffer.put(bite,)@!(!(rawBuffer.hasRemaining())) -> IF { -> throw new IOException("CRLF not found before max message length: "+maxMessageSize,)@!(!(rawBuffer.hasRemaining())) && buildBuffer.position()>=buildBuffer.limit() } } } } CATCH(IOException) {}
results[https://github.com/freenet/plugin-Freetalk-official/blob/492ff95d9a2724d525f1ef902244fd82bd850b2b/ui/NNTP/FreetalkNNTPHandler.java][readTextDataBytes][2] = -> TRY {  -> buf=ByteBuffer.allocate(1024,)@ -> LOOP { -> line=readLineBytes(is,)@ -> IF { -> return null@!(line.hasRemaining()) } -> IF { -> IF { -> buf.flip()@!(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') && !(!(line.hasRemaining())) && !(line.get(0,)=='.') -> return buf@line.get(0,)=='.' && line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n' && !(!(line.hasRemaining())) } ELSE { -> line.get()@line.get(0,)=='.' && !(!(line.hasRemaining())) && !(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') } } -> IF { -> newbuf=ByteBuffer.allocate(buf.position()+line.remaining()*2,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> buf.flip()@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> newbuf.put(buf,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') } -> buf.put(line,)@!(!(line.hasRemaining())) && !(line.get(0,)=='.') } } CATCH(IOException) {}
results[https://github.com/nschlimm/playground/blob/80ec4a6c8155f90fee7ea8d2b91cbef2296529be/master-playground/src/test/java/com/schlimm/master/io/nio/Buffers.java][main][1] = -> buffer=ByteBuffer.allocate(1024,)@ -> hello="Hello".getBytes()@ -> buffer.put(hello,)@ -> System.out.println("Capacity: "+buffer.capacity(),)@ -> System.out.println("Limit: "+buffer.limit(),)@ -> System.out.println("Position: "+buffer.position(),)@ -> buffer.flip()@ -> System.out.println("Capacity: "+buffer.capacity(),)@ -> System.out.println("Limit: "+buffer.limit(),)@ -> System.out.println("Position: "+buffer.position(),)@ -> LOOP { -> System.out.println((char) buffer.get(),)@buffer.hasRemaining() } -> anotherBuffer=ByteBuffer.allocate(1024,)@ -> heinz="8Bytes--".getBytes()@ -> anotherBuffer.put(heinz,)@ -> anotherBuffer.flip()@ -> System.out.println(anotherBuffer.getDouble(),)@
results[https://github.com/yudis/h2database/blob/81401dda5140b14c098a3094adb6ef09cd31a1e8/h2/src/tools/org/h2/dev/store/btree/StreamStore.java][nextBuffer][1] = -> LOOP { -> idBuffer.get()@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> IF { -> idBuffer.position(idBuffer.position()+len,)@skip>=len && idBuffer.hasRemaining() } -> p=(int) idBuffer.position()+skip@idBuffer.hasRemaining() -> idBuffer.position(p+l,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(idBuffer.array(),p,l,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(data,s,data.length-s,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> k=store.getBlock(key,)@!(idBuffer.hasRemaining()) -> newBuffer=ByteBuffer.allocate(k.length+idBuffer.limit()-idBuffer.position(),)@idBuffer.hasRemaining() -> newBuffer.put(k,)@!(idBuffer.hasRemaining()) -> newBuffer.put(idBuffer,)@idBuffer.hasRemaining() -> newBuffer.flip()@!(idBuffer.hasRemaining()) -> return nextBuffer()@idBuffer.hasRemaining() -> throw new IllegalArgumentException("Unsupported id",)@idBuffer.hasRemaining() }
results[https://github.com/ferquies/2dam/blob/3449ac78542b4597a76f1860dc4ce81472854e44/AD/Tema 2/h2/src/main/org/h2/mvstore/StreamStore.java][nextBuffer][4] = -> LOOP { -> idBuffer.get()@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> IF { -> idBuffer.position(idBuffer.position()+len,)@skip>=len && idBuffer.hasRemaining() } -> p=(int) idBuffer.position()+skip@idBuffer.hasRemaining() -> idBuffer.position(p+l,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(idBuffer.array(),p,l,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(data,s,data.length-s,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> k=store.getBlock(key,)@!(idBuffer.hasRemaining()) -> newBuffer=ByteBuffer.allocate(k.length+idBuffer.limit()-idBuffer.position(),)@idBuffer.hasRemaining() -> newBuffer.put(k,)@!(idBuffer.hasRemaining()) -> newBuffer.put(idBuffer,)@idBuffer.hasRemaining() -> newBuffer.flip()@!(idBuffer.hasRemaining()) -> return nextBuffer()@idBuffer.hasRemaining() -> throw DataUtils.newIllegalArgumentException("Unsupported id {0}",Arrays.toString(idBuffer.array(),),)@idBuffer.hasRemaining() }
results[https://github.com/svn2github/H2-Mirror/blob/af599f8ace132827af4589352bd72bc4743eba57/h2/src/main/org/h2/mvstore/StreamStore.java][nextBuffer][1] = -> LOOP { -> idBuffer.get()@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> IF { -> idBuffer.position(idBuffer.position()+len,)@skip>=len && idBuffer.hasRemaining() } -> p=(int) idBuffer.position()+skip@idBuffer.hasRemaining() -> idBuffer.position(p+l,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(idBuffer.array(),p,l,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(data,s,data.length-s,)@idBuffer.hasRemaining() -> len=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> k=store.getBlock(key,)@!(idBuffer.hasRemaining()) -> newBuffer=ByteBuffer.allocate(k.length+idBuffer.limit()-idBuffer.position(),)@idBuffer.hasRemaining() -> newBuffer.put(k,)@!(idBuffer.hasRemaining()) -> newBuffer.put(idBuffer,)@idBuffer.hasRemaining() -> newBuffer.flip()@!(idBuffer.hasRemaining()) -> return nextBuffer()@idBuffer.hasRemaining() -> throw DataUtils.newIllegalArgumentException("Unsupported id {0}",Arrays.toString(idBuffer.array(),),)@idBuffer.hasRemaining() }
results[https://github.com/freenet/plugin-Freetalk-staging/blob/b21b89c87bc2eca138fedf9b0224f5f273a89d60/src/plugins/Freetalk/ui/NNTP/FreetalkNNTPHandler.java][readTextDataBytes][2] = -> TRY {  -> buf=ByteBuffer.allocate(Math.max(4096,Math.min(is.available(),64*1024,),),)@ -> LOOP { -> line=readLineBytes(is,)@ -> IF { -> return null@!(line.hasRemaining()) } -> IF { -> IF { -> buf.flip()@!(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') && !(!(line.hasRemaining())) && !(line.get(0,)=='.') -> return buf@line.get(0,)=='.' && line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n' && !(!(line.hasRemaining())) } ELSE { -> line.get()@line.get(0,)=='.' && !(!(line.hasRemaining())) && !(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') } } -> IF { -> newbuf=ByteBuffer.allocate(buf.position()+line.remaining()*2,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> buf.flip()@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> newbuf.put(buf,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') } -> buf.put(line,)@!(!(line.hasRemaining())) && !(line.get(0,)=='.') } } CATCH(IOException) {}
results[https://github.com/TooTallNate/Java-WebSocket/blob/2d833695699fad80313b618275f31727c618748b/src/net/tootallnate/drafts/Draft_75.java][translateFrame][2] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() } ELSE { -> IF { -> IF { -> curframe.setPayload(currentFrame.array(),)@this.currentFrame!=null } } ELSE { -> frame=ByteBuffer.allocate(checkAlloc((this.currentFrame!=null)?this.currentFrame.capacity():0+1,),)@ -> IF { -> this.currentFrame.rewind()@this.currentFrame!=null -> frame.put(this.currentFrame,)@this.currentFrame!=null } -> frame.put(newestByte,)@!(newestByte==START_OF_FRAME&&!(readingState)) && !(newestByte==END_OF_FRAME&&readingState) } } -> IF { -> curframe.setPayload(currentFrame.array(),)@ } } CATCH(InvalidDataException) {}
results[https://github.com/undertow-io/undertow/blob/cc45b5a30e7c728201decbaa3f2939dcd5ac711f/core/src/main/java/io/undertow/util/MultipartParser.java][handle][1] = -> TRY {  -> buf=resource.getResource()@ -> TRY { -> LOOP { -> b=rawData.get()@rawData.hasRemaining() -> IF { } ELSE { -> result=Character.digit((char) firstCharacter,16,)@!(firstCharacter==0) -> result+=Character.digit((char) b,16,)@ -> buf.put((byte) result,)@ } ELSE { } ELSE { -> buf.put(b,)@!(b=='=') -> IF { -> buf.flip()@!(buf.hasRemaining()) -> handler.data(buf,)@!(buf.hasRemaining()) -> buf.clear()@!(buf.hasRemaining()) } } } -> buf.flip()@ -> handler.data(buf,)@ } FINALLY { -> resource.free()@ } } CATCH(IOException) {}
results[https://github.com/hazelcast/hazelcast/blob/4a923f283aa641f947eed63633e1e584bf570090/hazelcast/src/main/java/com/hazelcast/ascii/rest/HttpPostCommand.java][doActualRead][2] = -> IF { -> IF { -> hasLine=readLine(cb,)@!(chunked&&data==null||!(data.hasRemaining())) && !(readyToReadData) -> IF { -> lineStr=toStringAndClear(line,).trim()@!(chunked&&data==null||!(data.hasRemaining())) && !(readyToReadData) } -> IF { -> IF { -> return true@dataSize==0 && chunked&&data==null||!(data.hasRemaining()) && readyToReadData && hasLine } -> IF { -> newData=ByteBuffer.allocate(data.capacity()+dataSize,)@!(dataSize==0) && chunked&&data==null||!(data.hasRemaining()) && !(readyToReadData) && data!=null && !(hasLine) -> newData.put(data.array(),)@!(dataSize==0) && chunked&&data==null||!(data.hasRemaining()) && !(readyToReadData) && data!=null && !(hasLine) } ELSE { -> data=ByteBuffer.allocate(dataSize,)@!(data!=null) && !(dataSize==0) && chunked&&data==null||!(data.hasRemaining()) && !(readyToReadData) && !(hasLine) } } } -> IOUtil.copyToHeapBuffer(cb,data,)@!(chunked&&data==null||!(data.hasRemaining())) && !(readyToReadData) } -> LOOP { -> b=cb.get()@!(readyToReadData) && !(readyToReadData)&&cb.hasRemaining() -> c=(char) b@!(readyToReadData) -> IF { -> processLine(toStringAndClear(line,).toLowerCase(),)@!(readyToReadData) } ELSE { -> IF { -> line.put(b,)@!(readyToReadData) } } } -> return !(chunked)&&data!=null&&!(data.hasRemaining())@!(readyToReadData)
results[https://github.com/sigmarkarl/world/blob/4fc8f09bd8c98be19a05f3bed4ff0e6f33406f2d/javafasta/src/org/java_websocket/drafts/Draft_75.java][translateRegularFrame][7] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() -> IF { -> IF { -> throw new InvalidFrameException("unexpected START_OF_FRAME",)@buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> throw new InvalidFrameException("unexpected END_OF_FRAME",)@newestByte==END_OF_FRAME && buffer.hasRemaining() && !(newestByte==START_OF_FRAME) } -> IF { -> currentFrame.flip()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> curframe.setPayload(currentFrame,)@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> buffer.mark()@newestByte==END_OF_FRAME && buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> currentFrame=createBuffer()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && currentFrame==null } ELSE { -> IF { -> currentFrame=increaseBuffer(currentFrame,)@newestByte==END_OF_FRAME && !(currentFrame.hasRemaining()) && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && !(currentFrame==null) } } -> currentFrame.put(newestByte,)@!(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) && !(buffer.hasRemaining()) } ELSE { -> return null@buffer.hasRemaining() && !(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) } } } } } CATCH(InvalidDataException) {}
results[https://github.com/alecgorge/jsonapi/blob/026504f7b776ccf1d975d9b49df56bdd645fb3c0/src/org/java_websocket/drafts/Draft_75.java][translateRegularFrame][1] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() -> IF { -> IF { -> return null@buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> return null@newestByte==END_OF_FRAME && buffer.hasRemaining() && !(newestByte==START_OF_FRAME) } -> IF { -> currentFrame.flip()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> curframe.setPayload(currentFrame,)@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> buffer.mark()@newestByte==END_OF_FRAME && buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> currentFrame=createBuffer()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && currentFrame==null } ELSE { -> IF { -> currentFrame=increaseBuffer(currentFrame,)@newestByte==END_OF_FRAME && !(currentFrame.hasRemaining()) && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && !(currentFrame==null) } } -> currentFrame.put(newestByte,)@!(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) && !(buffer.hasRemaining()) } ELSE { -> return null@buffer.hasRemaining() && !(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) } } } } -> IF { -> curframe.setPayload(currentFrame,)@!(buffer.hasRemaining()) } } CATCH(InvalidDataException) {}
results[https://github.com/TooTallNate/Java-WebSocket/blob/fb407e530801cc88257d4c095f92ab050a5d736b/src/org/java_websocket/drafts/Draft_75.java][translateRegularFrame][7] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() -> IF { -> IF { -> return null@buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> return null@newestByte==END_OF_FRAME && buffer.hasRemaining() && !(newestByte==START_OF_FRAME) } -> IF { -> currentFrame.flip()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> curframe.setPayload(currentFrame,)@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> buffer.mark()@newestByte==END_OF_FRAME && buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> currentFrame=createBuffer()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && currentFrame==null } ELSE { -> IF { -> currentFrame=increaseBuffer(currentFrame,)@newestByte==END_OF_FRAME && !(currentFrame.hasRemaining()) && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && !(currentFrame==null) } } -> currentFrame.put(newestByte,)@!(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) && !(buffer.hasRemaining()) } ELSE { -> return null@buffer.hasRemaining() && !(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) } } } } -> IF { -> currentFrame.flip()@!(buffer.hasRemaining()) -> curframe.setPayload(currentFrame,)@!(buffer.hasRemaining()) } } CATCH(InvalidDataException) {}
results[https://github.com/jazzlly/Notes/blob/35ef22912d5bde4a92ef06360094e1147c8e3b37/computer.science/languages/java/network/PushServerTest/src/org/java_websocket/drafts/Draft_10.java][createBinaryFrame][6] = -> mes=framedata.getPayloadData()@ -> sizebytes=(mes.remaining()<=125)?1:(mes.remaining()<=65535)?2:8@ -> buf=ByteBuffer.allocate(1+(sizebytes>1)?sizebytes+1:sizebytes+(mask)?4:0+mes.remaining(),)@ -> one=(byte) (framedata.isFin())?-128:0@ -> buf.put(one,)@ -> payloadlengthbytes=toByteArray(mes.remaining(),sizebytes,)@ -> IF { -> buf.put((byte) (byte) payloadlengthbytes[0]|(mask)?(byte) -128:0,)@sizebytes==1 } ELSE { -> IF { -> buf.put((byte) (byte) 126|(mask)?(byte) -128:0,)@sizebytes==1 && sizebytes==2 -> buf.put(payloadlengthbytes,)@sizebytes==1 && sizebytes==2 } ELSE { -> IF { -> buf.put((byte) (byte) 127|(mask)?(byte) -128:0,)@sizebytes==1 && sizebytes==2 && sizebytes==8 -> buf.put(payloadlengthbytes,)@sizebytes==1 && sizebytes==2 && sizebytes==8 } ELSE { -> throw new RuntimeException("Size representation not supported/specified",)@!(sizebytes==2) && !(sizebytes==8) && !(sizebytes==1) } } } -> IF { -> maskkey=ByteBuffer.allocate(4,)@sizebytes==1 -> maskkey.putInt(reuseableRandom.nextInt(),)@sizebytes==1 -> buf.put(maskkey.array(),)@sizebytes==1 -> LOOP { -> buf.put((byte) mes.get()^maskkey.get(i%4,),)@sizebytes==1 && mes.hasRemaining() } } ELSE { -> buf.put(mes,)@sizebytes==1 } -> assert buf.remaining()@sizebytes==1 -> buf.flip()@sizebytes==1
results[https://github.com/develar/chromedevtools/blob/293c27ed651f2e37b2859af8ddf93acb08c1c164/platform-backend/src/org/chromium/sdk/internal/transport/LineReader.java][readLine][4] = -> TRY {  -> lineBuffer.clear()@ -> LOOP { -> IF { -> pos=buffer.position()@buffer.hasRemaining() -> chunkLen=pos-buffer.position()@buffer.hasRemaining() -> IF { -> IF { -> newSize=Math.max(lineBuffer.capacity()*2,lineBuffer.position()+chunkLen,)@chunkLen>0 && lineBuffer.remaining()<chunkLen -> newLineBuffer=ByteBuffer.allocate(newSize,)@ -> lineBuffer.flip()@lineBuffer.remaining()<chunkLen -> newLineBuffer.put(lineBuffer,)@lineBuffer.remaining()<chunkLen } -> buffer.get(lineBuffer.array(),lineBuffer.position(),chunkLen,)@buffer.hasRemaining() && chunkLen>0 -> lineBuffer.position(lineBuffer.position()+chunkLen,)@chunkLen>0 } -> IF { -> buffer.get()@buffer.hasRemaining() } } -> assert !(buffer.hasRemaining())@ -> buffer.clear()@ -> readRes=inputStream.read(buffer.array(),)@ -> IF { -> IF { -> return null@lineBuffer.position()==0 && readRes<=0 } ELSE { -> throw new IOException("End of stream while expecting line end",)@!(lineBuffer.position()==0) && readRes<=0 } } -> buffer.position(readRes,)@!(readRes<=0) -> buffer.flip()@!(readRes<=0) } -> IF { -> lineBuffer.position(lineBuffer.position()-1,)@lineBuffer.position()>0&&lineBuffer.get(lineBuffer.position()-1,)==CR_BYTE } -> return new String(lineBuffer.array(),0,lineBuffer.position(),charset,)@ } CATCH(IOException) {}
results[https://github.com/undertow-io/undertow/blob/ce84a32632d19a24548fa61b38551772864fd849/core/src/main/java/io/undertow/util/ChunkedStreamSinkChannel.java][write][1] = -> TRY {  -> TRY { -> IF { -> return 0@!(src.hasRemaining()) } -> buff=buffer.getResource()@!(!(src.hasRemaining())) -> maxSize=buff.capacity()-CHUNKING_OVERHEAD_MAX_BYTES@!(!(src.hasRemaining())) -> toWrite=Math.min(src.remaining(),maxSize,)@!(!(src.hasRemaining())) -> buff.clear()@!(!(src.hasRemaining())) -> buff.put(Integer.toHexString(toWrite,).getBytes(),)@!(!(src.hasRemaining())) -> buff.put(CRLF,)@!(!(src.hasRemaining())) -> buff.flip()@!(!(src.hasRemaining())) -> writeBuffer(buff,)@!(!(src.hasRemaining())) -> IF { -> IF { -> log.tracef("Copying into our buffer, as src size of %s was bigger than %s",src.remaining(),maxSize,)@toWrite!=src.remaining() && log.isTraceEnabled() && !(!(src.hasRemaining())) } -> buff.compact()@toWrite!=src.remaining() && !(!(src.hasRemaining())) -> LOOP { -> buff.put(src.get(),)@toWrite!=src.remaining() && !(!(src.hasRemaining())) } -> buff.put(CRLF,)@toWrite!=src.remaining() && !(!(src.hasRemaining())) -> buff.flip()@toWrite!=src.remaining() && !(!(src.hasRemaining())) -> writeBuffer(buff,)@toWrite!=src.remaining() && !(!(src.hasRemaining())) } ELSE { -> IF { -> buff.compact()@toWrite!=src.remaining() && !(!(src.hasRemaining())) && buff.hasRemaining() } ELSE { -> writeBuffer(src,)@!(!(src.hasRemaining())) && buff.hasRemaining() && !(toWrite!=src.remaining()) -> IF { -> buff.clear()@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> buff.put(CRLF,)@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> buff.flip()@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> writeBuffer(buff,)@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> return toWrite@!(src.hasRemaining()) && !(buff.hasRemaining()) && !(toWrite!=src.remaining()) } } -> buff.put(src,)@!(!(src.hasRemaining())) && buff.hasRemaining() && !(toWrite!=src.remaining()) -> buff.put(CRLF,)@toWrite!=src.remaining() && !(!(src.hasRemaining())) && buff.hasRemaining() -> buff.flip()@toWrite!=src.remaining() && !(!(src.hasRemaining())) && buff.hasRemaining() } } FINALLY { -> exit(val,FLAG_IN_WRITE|clearFlags,exitFlag,)@!(!(src.hasRemaining())) } } CATCH(IOException) {}
results[https://github.com/cm4j/cm4j-all/blob/2543e6c70a6fb559e74e28000c0261d71e61bae3/cm4j-test/src/main/java/com/cm4j/test/syntax/nio/s4_selector/SelectSockets.java][readDataFromSocket][1] = -> TRY {  -> buffer.clear()@ -> LOOP { -> buffer.flip()@(count=socketChannel.read(buffer,))>0 -> LOOP { -> result=buffer.get()@(count=socketChannel.read(buffer,))>0 && buffer.hasRemaining() -> System.out.println("server received:"+(char) result,)@ -> buffer.put(result,)@(count=socketChannel.read(buffer,))>0 && buffer.hasRemaining() -> socketChannel.write(buffer,)@(count=socketChannel.read(buffer,))>0 && buffer.hasRemaining() } -> buffer.clear()@(count=socketChannel.read(buffer,))>0 } } CATCH(Exception) {}
results[https://github.com/lemmy/Openfire4OSGi/blob/d9adebb8583090b92b83b305f8e41f673653f47e/src/java/org/jivesoftware/openfire/net/TLSStreamWriter.java][tlsWrite][4] = -> TRY {  -> buf.hasRemaining()@ -> LOOP { -> tlsBuffer=ByteBuffer.allocate(Math.min(buf.remaining(),wrapper.getAppBuffSize(),),)@ -> LOOP { -> tlsBuffer.put(buf.get(),)@tlsBuffer.hasRemaining()&&buf.hasRemaining() } -> tlsBuffer.flip()@ -> wrapper.wrap(tlsBuffer,tlsOutput,)@ } } CATCH(IOException) {}
results[https://github.com/wordrak/kryo/blob/81fd8015ba7e9dcf73b83d7d06e00d0630b67365/src/com/esotericsoftware/kryo/compress/Delta.java][longestMatch][2] = -> LOOP { -> IF { -> sbuf.clear()@!(sbuf.hasRemaining()) -> TRY { -> IF { -> return match@!(sourceBuffer.hasRemaining()) && !(sbuf.hasRemaining()) } -> LOOP { -> sbuf.put(sourceBuffer.get(),)@!(sbuf.hasRemaining()) && sourceBuffer.hasRemaining()&&sbuf.hasRemaining() && !(!(sourceBuffer.hasRemaining())) } } FINALLY { -> sbuf.flip()@!(sbuf.hasRemaining()) && !(!(sourceBuffer.hasRemaining())) } } -> IF { -> return match@!(tbuf.hasRemaining())&&!(readMore()) && !(!(sbuf.hasRemaining())) } -> IF { -> return match@sbuf.get()!=tbuf.get() && !(!(sbuf.hasRemaining())) && !(!(tbuf.hasRemaining())&&!(readMore())) } }
results[https://github.com/Smartupz/tigase-server/blob/9243406d4d9c5f635e99ff60eb9bfa80c1df77c4/src/tigase/io/TLSIO.java][write][1] = -> TRY {  -> log.finer("TLS - Writing data, remaining: "+buff.remaining(),)@ -> buff.hasRemaining()@ -> LOOP { -> tlsBuffer=ByteBuffer.allocate(Math.min(buff.remaining(),tlsWrapper.getAppBuffSize(),),)@ -> LOOP { -> tlsBuffer.put(buff.get(),)@tlsBuffer.hasRemaining()&&buff.hasRemaining() } -> tlsBuffer.flip()@ -> tlsWrapper.wrap(tlsBuffer,tlsOutput,)@ -> IF { -> throw new EOFException("Socket has been closed.",)@tlsWrapper.getStatus()==TLSStatus.CLOSED } } } CATCH(IOException) {}
results[https://github.com/disy/jSCSI/blob/c5550dbb7fa9389f6f1afb355597ba3a2978307f/bundles/initiator/src/main/java/org/jscsi/initiator/connection/state/ReadResponseState.java][execute][1] = -> TRY {  -> LOOP { -> IF { -> IF { -> LOGGER.debug("Remaining, DataSegmentLength: "+buffer.remaining()+", "+protocolDataUnit.getBasicHeaderSegment().getDataSegmentLength(),)@protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser } -> dataSegment=protocolDataUnit.getDataSegment()@protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser -> LOOP { -> buffer.put(dataSegment.get(),)@!(protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser) && buffer.hasRemaining()&&dataSegment.hasRemaining() } -> IF { -> return @protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser && parser.isStatusFlag()&&parser.getStatus()==SCSIStatus.GOOD } ELSE { -> IF { -> return @protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser && !(parser.isStatusFlag()&&parser.getStatus()==SCSIStatus.GOOD) && connection.getSettingAsInt(OperationalTextKey.ERROR_RECOVERY_LEVEL,)>0&&parser.isAcknowledgeFlag() } } } } } CATCH(InternetSCSIException) {}
results[https://github.com/xnio/xnio/blob/1753816e17c26d294bc371ee0af7aa9b8b7c4891/api/src/test/java/org/xnio/BuffersTestCase.java][testZeroByteBuffer][1] = -> buffer1=ByteBuffer.allocate(23,)@ -> buffer2=ByteBuffer.allocate(24,)@ -> LOOP { -> buffer1.put((byte) i,)@i<23 -> buffer2.put((byte) i,)@i<23 } -> buffer2.put((byte) 23,)@ -> Buffers.zero(buffer1,)@ -> Buffers.zero(buffer2,)@ -> assertEquals(0,buffer1.position(),)@ -> assertEquals(0,buffer2.position(),)@ -> assertEquals(buffer1.capacity(),buffer1.limit(),)@ -> assertEquals(buffer2.capacity(),buffer2.limit(),)@ -> LOOP { -> assertEquals(0,buffer1.get(),)@buffer1.hasRemaining() } -> LOOP { -> assertEquals(0,buffer2.get(),)@buffer2.hasRemaining() }
results[https://github.com/CSEMike/OneSwarm/blob/b3dc53158fdae221d9c54371b01abfe192bbf74b/oneswarm_f2f/src/edu/washington/cs/oneswarm/f2f/network/OverlayTransport.java][putInBuffers][1] = -> IF { -> LOOP { -> numBytesToCopy=Math.min(t.remaining(),source.remaining(),)@ -> IF { -> oldLimit=source.limit()@t.remaining()<source.remaining() -> source.limit(source.position()+t.remaining(),)@t.remaining()<source.remaining() -> t.put(source,)@t.remaining()<source.remaining() -> source.limit(oldLimit,)@t.remaining()<source.remaining() } ELSE { -> t.put(source,)@!(t.remaining()<source.remaining()) } } } ELSE { -> LOOP { -> LOOP { -> b=source.get()@targets[i].hasRemaining()&&source.hasRemaining() -> b=modifyIncomingHandShake(b,)@ -> targets[i].put(b,)@i<array_offset+length && targets[i].hasRemaining()&&source.hasRemaining() } } }
results[https://github.com/apache/tomcat70/blob/dc4219f65c06f5459382798bc1e272fa73bacd19/modules/websocket/java/org/apache/tomcat/websocket/WsRemoteEndpointImplBase.java][write][1] = -> LOOP { -> outputBuffer.put(headerBuffer.get(),)@headerBuffer.hasRemaining()&&outputBuffer.hasRemaining() } -> IF { -> outputBuffer.flip()@!(headerBuffer.hasRemaining()) -> endpoint.doWrite(this,outputBuffer,)@!(headerBuffer.hasRemaining()) -> return @headerBuffer.hasRemaining() } -> LOOP { -> IF { -> outputBuffer.put(payload.get(),)@!(headerBuffer.hasRemaining()) && payload.hasRemaining()&&outputBuffer.hasRemaining() } ELSE { -> outputBuffer.put((byte) payload.get()^mask[++maskIndex]&0xFF,)@!(mask==null) && !(headerBuffer.hasRemaining()) && payload.hasRemaining()&&outputBuffer.hasRemaining() } } -> IF { -> outputBuffer.flip()@!(headerBuffer.hasRemaining()) && !(payload.hasRemaining()) -> endpoint.doWrite(this,outputBuffer,)@!(headerBuffer.hasRemaining()) && !(payload.hasRemaining()) -> return @!(headerBuffer.hasRemaining()) && payload.hasRemaining() } -> IF { -> outputBuffer.flip()@!(headerBuffer.hasRemaining()) && !(payload.hasRemaining()) } ELSE { -> endpoint.doWrite(this,outputBuffer,)@!(outputBuffer.remaining()==0) && !(headerBuffer.hasRemaining()) && !(payload.hasRemaining()) }
results[https://github.com/develar/chromedevtools/blob/fb3d56ea36698cce3e4baca1903838dfff0cdba1/platform-backend/src/org/chromium/sdk/util/ByteToCharConverter.java][convertImpl][4] = -> bytesCount=input.remaining()+unprocessedBuffer.remaining()+1@ -> IF { -> LOOP { -> IF { -> return out@!(input.hasRemaining()) && unprocessedBuffer.hasRemaining() } -> unprocessedBuffer.compact()@unprocessedBuffer.hasRemaining() && !(!(input.hasRemaining())) -> unprocessedBuffer.put(input.get(),)@unprocessedBuffer.hasRemaining() && !(!(input.hasRemaining())) -> unprocessedBuffer.flip()@unprocessedBuffer.hasRemaining() && !(!(input.hasRemaining())) -> res=decoder.decode(unprocessedBuffer,out,false,)@unprocessedBuffer.hasRemaining() && !(!(input.hasRemaining())) -> IF { -> throw new RuntimeException("Unexpected error: "+res,)@unprocessedBuffer.hasRemaining() && !(!(input.hasRemaining())) && !(res.isUnderflow()) } -> IF { -> assert !(unprocessedBuffer.hasRemaining())@unprocessedBuffer.position()>0 && !(!(res.isUnderflow())) && unprocessedBuffer.hasRemaining() && !(!(input.hasRemaining())) } } } -> IF { -> return out@!(input.hasRemaining()) && !(unprocessedBuffer.hasRemaining()) } -> res=decoder.decode(input,out,false,)@!(unprocessedBuffer.hasRemaining()) && !(!(input.hasRemaining())) -> unprocessedBuffer.clear()@!(!(res.isUnderflow())) && !(unprocessedBuffer.hasRemaining()) && !(!(input.hasRemaining())) -> LOOP { -> unprocessedBuffer.put(input.get(),)@!(!(res.isUnderflow())) && !(unprocessedBuffer.hasRemaining()) && !(!(input.hasRemaining())) && input.hasRemaining() } -> unprocessedBuffer.flip()@!(!(res.isUnderflow())) && !(unprocessedBuffer.hasRemaining()) && !(!(input.hasRemaining()))
results[https://github.com/ikeji/openjdk7-jdk/blob/ac3faf88491f55369fb6b83f77fbb75557ed3bf4/test/java/nio/channels/spi/SelectorProvider/inheritedChannel/EchoTest.java][TCPEchoTest][3] = -> TRY {  -> size=msg.length()*repeat@ -> bb1=ByteBuffer.allocate(size,)@ -> LOOP { -> bb1.put(msg.getBytes("UTF-8",),)@ } -> bb1.flip()@ -> sc.write(bb1,)@ -> bb2=ByteBuffer.allocate(size+100,)@ -> LOOP { -> IF { -> n=sc.read(bb2,)@ } } } ELSE { -> bb1.flip()@ -> bb2.flip()@ -> IF { -> bb2.flip()@ -> LOOP { -> c=(char) bb2.get()@bb2.hasRemaining() -> System.out.print(c,)@ } } } CATCH(IOException) {}
results[https://github.com/undertow-io/undertow/blob/0c57bb3641344368cd2f53eed99ab7b7d69c5769/websockets/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07CloseFrameSourceChannel.java][read0][2] = -> TRY {  -> IF { -> LOOP { -> dst.put(status.get(),)@dst.hasRemaining()&&status.hasRemaining() && status.hasRemaining() } -> return copied@status.hasRemaining() } ELSE { -> return super.read0(dst,)@!(status.hasRemaining()) } } CATCH(IOException) {}
results[https://github.com/undertow-io/undertow/blob/b6e3196e98e43d597221e901cb681efd5af442c8/core/src/main/java/io/undertow/websockets/core/protocol/version07/WebSocket07CloseFrameSourceChannel.java][read][1] = -> TRY {  -> IF { -> LOOP { -> dst.put(status.get(),)@dst.hasRemaining()&&status.hasRemaining() && status.hasRemaining() } -> return copied@status.hasRemaining() } ELSE { -> return super.read(dst,)@!(status.hasRemaining()) } } CATCH(IOException) {}
results[https://github.com/chototsu/MikuMikuStudio/blob/18b8fc668a5ba436c801858ca2957d63b08d220d/engine/src/blender/com/jme3/scene/plugins/blender/textures/blending/TextureBlenderDDS.java][blend][2] = -> LOOP { -> data=image.getData(dataLayerIndex,)@dataLayerIndex<depth -> data.rewind()@ -> newData=BufferUtils.createByteBuffer(data.remaining(),)@ -> LOOP { -> IF { -> alpha=data.getLong()@data.hasRemaining() -> alpha0=(byte) alpha<<4&0xFF@ -> alpha1=(byte) alpha>>60&0xFF@ -> alphas[0]=(alpha0>=0)?alpha0/255.0f:1.0f-~alpha0/255.0f@ -> alphas[1]=(alpha1>=0)?alpha1/255.0f:1.0f-~alpha1/255.0f@ -> newData.putLong(alpha,)@ } ELSE { -> IF { -> alpha0=data.get()@data.hasRemaining() -> alpha1=data.get()@data.hasRemaining() -> alphas[0]=(alpha0>=0)?alpha0/255.0f:1.0f-~alpha0/255.0f@ -> alphas[1]=(alpha1>=0)?alpha0/255.0f:1.0f-~alpha0/255.0f@ -> newData.put(alpha0,)@ -> newData.put(alpha1,)@ -> newData.putInt(data.getInt(),)@data.hasRemaining() -> newData.putShort(data.getShort(),)@data.hasRemaining() } } -> col0=RGB565.RGB565_to_ARGB8(data.getShort(),)@data.hasRemaining() -> col1=RGB565.RGB565_to_ARGB8(data.getShort(),)@data.hasRemaining() -> LOOP { -> newData.putShort(rgb565,)@ } -> newData.putInt(data.getInt(),)@data.hasRemaining() } -> dataArray.add(newData,)@ }
results[https://github.com/john-tornblom/TVHGuide/blob/e6546e42ca8f8380d784d1693b4fa661e5284e03/src/org/tvheadend/tvhguide/htsp/HTSMessage.java][deserializeBinary][2] = -> TRY {  -> LOOP { -> type=buf.get()@buf.hasRemaining() -> namelen=buf.get()@buf.hasRemaining() -> datalen=uIntToLong(buf.get(),buf.get(),buf.get(),buf.get(),)@buf.hasRemaining() -> IF { -> throw new IOException("Would get precision losses ;(",)@buf.hasRemaining() && datalen>Integer.MAX_VALUE } -> IF { -> throw new IOException("Buffer limit exceeded",)@!(datalen>Integer.MAX_VALUE) && buf.hasRemaining() && buf.limit()<namelen+datalen } } ELSE { -> buf.get(bName,)@!(datalen>Integer.MAX_VALUE) && buf.hasRemaining() && !(buf.limit()<namelen+datalen) -> name=new String(bName,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> buf.get(bData,)@!(datalen>Integer.MAX_VALUE) && buf.hasRemaining() && !(buf.limit()<namelen+datalen) -> obj=new String(bData,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> obj=toBigInteger(bData,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> sub=ByteBuffer.allocateDirect((int) datalen,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> sub.put(bData,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> sub.flip()@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> obj=deserializeBinary(sub,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> sub=ByteBuffer.allocateDirect((int) datalen,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> sub.put(bData,)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> sub.flip()@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> obj=new ArrayList<Object>(deserializeBinary(sub,).values(),)@!(datalen>Integer.MAX_VALUE) && !(buf.hasRemaining()) && !(buf.limit()<namelen+datalen) -> throw new IOException("Unknown data type",)@!(datalen>Integer.MAX_VALUE) && buf.hasRemaining() && !(buf.limit()<namelen+datalen) } } CATCH(IOException) {}
results[https://github.com/disy/jSCSI/blob/7dc545a6574be01137cb7b88d24a4282e10282ac/jSCSI-deprecated/src/org/jscsi/connection/ReadResponseState.java][execute][1] = -> TRY {  -> LOOP { -> IF { -> IF { -> LOGGER.debug("Remaining, DataSegmentLength: "+buffer.remaining()+", "+protocolDataUnit.getBasicHeaderSegment().getDataSegmentLength(),)@protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser } -> dataSegment=protocolDataUnit.getDataSegment()@protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser -> LOOP { -> buffer.put(dataSegment.get(),)@protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser && buffer.hasRemaining()&&dataSegment.hasRemaining() } -> IF { -> return false@protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser && parser.isStatusFlag()&&parser.getStatus()==SCSIStatus.GOOD } ELSE { -> IF { -> return true@protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser && !(parser.isStatusFlag()&&parser.getStatus()==SCSIStatus.GOOD) && connection.getSettingAsInt(OperationalTextKey.ERROR_RECOVERY_LEVEL,)>0&&parser.isAcknowledgeFlag() } } } ELSE { -> IF { -> dataSegment=protocolDataUnit.getDataSegment()@!(protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser) && protocolDataUnit.getBasicHeaderSegment().getParser() instanceof SCSIResponseParser -> LOOP { -> buffer.put(dataSegment.get(),)@!(protocolDataUnit.getBasicHeaderSegment().getParser() instanceof SCSIResponseParser) && protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser && buffer.hasRemaining()&&dataSegment.hasRemaining() } -> IF { -> return false@parser.getStatus()==SCSIStatus.GOOD && !(protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser) && protocolDataUnit.getBasicHeaderSegment().getParser() instanceof SCSIResponseParser } ELSE { -> throw new RuntimeException()@!(parser.getStatus()==SCSIStatus.GOOD) && !(protocolDataUnit.getBasicHeaderSegment().getParser() instanceof DataInParser) && protocolDataUnit.getBasicHeaderSegment().getParser() instanceof SCSIResponseParser } } } } } CATCH(InternetSCSIException) {}
results[https://github.com/metamx/druid/blob/50b6888210c432304730459731bb749ff52230f3/processing/src/main/java/io/druid/query/aggregation/hyperloglog/HyperLogLogCollector.java][fold][1] = -> IF { -> return this@other==null||other.storageBuffer.remaining()==0 } -> IF { -> newStorage=ByteBuffer.allocateDirect(other.storageBuffer.remaining(),)@!(other==null||other.storageBuffer.remaining()==0) -> newStorage.put(other.storageBuffer.asReadOnlyBuffer(),)@!(other==null||other.storageBuffer.remaining()==0) -> newStorage.clear()@!(other==null||other.storageBuffer.remaining()==0) } -> otherBuffer=other.storageBuffer.asReadOnlyBuffer()@!(other==null||other.storageBuffer.remaining()==0) -> numNonZero=getNumNonZeroRegisters()@!(other==null||other.storageBuffer.remaining()==0) -> IF { -> throw new ISE("offsetDiff[%d] < 0, shouldn't happen because of swap.",offsetDiff,)@offsetDiff<0 && !(other==null||other.storageBuffer.remaining()==0) } -> myPayloadStart=getPayloadBytePosition()@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) -> otherBuffer.position(other.getPayloadBytePosition(),)@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) -> IF { -> LOOP { -> payloadStartPosition=otherBuffer.getShort()-other.getNumHeaderBytes()@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) && otherBuffer.hasRemaining() && isSparse(otherBuffer,) -> numNonZero+=mergeAndStoreByteRegister(storageBuffer,myPayloadStart+payloadStartPosition,offsetDiff,otherBuffer.get(),)@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) && otherBuffer.hasRemaining() && isSparse(otherBuffer,) } -> IF { -> numNonZero=decrementBuckets()@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) && numNonZero==NUM_BUCKETS -> setNumNonZeroRegisters(numNonZero,)@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) && numNonZero==NUM_BUCKETS } } ELSE { -> position=getPayloadBytePosition()@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) -> LOOP { -> numNonZero+=mergeAndStoreByteRegister(storageBuffer,position,offsetDiff,otherBuffer.get(),)@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) && !(isSparse(otherBuffer,)) && otherBuffer.hasRemaining() } -> IF { -> numNonZero=decrementBuckets()@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) && numNonZero==NUM_BUCKETS -> setNumNonZeroRegisters(numNonZero,)@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0) && numNonZero==NUM_BUCKETS } } -> setNumNonZeroRegisters(numNonZero,)@!(other==null||other.storageBuffer.remaining()==0) && !(offsetDiff<0)
