\section{Related Work} 
Prior work has investigated the quality of code snippets in Stack Overflow. Several studies show that SO snippets are often incomplete and the API names appearing in these snippets are hard to resolve~\cite{dagenais2012recovering, subramanian2014live}. Zhou et al.~observe that 86 of 200 accepted SO posts use deprecated APIs but only 3 of them are reported by other users~\cite{zhou2016api}. Fischer et al.~ find that 29\% of security-related SO snippets are insecure and have potentially been reused to over 1 million Android apps on Google play~\cite{fischer2017stack}. Treude and Robillard conduct a survey to investigate comprehension difficulty of code examples in Stack Overflow~\cite{treude2017understanding}. The responses from GitHub users indicate that less than half of the SO examples are self-explanatory due to issues such as incomplete code and missing explanations. Though we draw motivation from these studies, {\tool} focuses on detecting API usage violations by contrasting SO code examples against common API usage patterns mined from GitHub. While {\tool} follows a similar style to Codota~\cite{codota}, Codota does not group related examples based on common API usage, does not quantify how many GitHub code snippets support the common usage, and does not detect API misuse by contrasting the SO post against desirable API usage mined from GitHub.

%The Codota Code Browsing Assistant for Chrome\footnote{https://www.codota.com/code-browsing-assistant} analyzes code snippets in web pages and enhances them with IDE-like features. A user may click on underlined code to view API documentation, references, and API-level compatibility issues, and may also save code snippets to view later in a CodeBox supported by Codota. {\tool}, which draws inspiration from this tool's user interface, instead focuses specifically on potential API misuse and does so by inferring common usage patterns from GitHub code projects, as opposed to using API documentation. {\tool} also uses code examples derived from required patterns as well as code examples in their original GitHub context to demonstrate a given pattern to a user as opposed to describing it with natural language or API documentation.

%{\bf API Usage Mining.} {\soa}'s API usage mining is described in further detail in {\todo cite the Maple paper?}. A large body of literature in API usage mining currently exists {\todo cite}, which uses a variety of techniques. However, to our knowledge these existing pattern mining techniques do not mine from massive code corpora with millions of projects. Gruska et al.~\cite{gruska2010learning} mines from the largest code corpus we are aware of, which comprises 6,000 Linux projects. Our pattern mining also uses a prediate mining technique to mine API call guard conditions in addition to API call ordering. To our knowledge, Ramanathan et al.~\cite{ramanathan2007static} and Nguyen et al.~\cite{nguyen2014mining} are the only other predicate mining techniques, and unlike these techniques we formalize the predicate equivalence problem as a satisfiability problem and leverage an SMT solver to group logically equivalent predicates during guard mining.