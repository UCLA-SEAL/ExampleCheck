package edu.ucla.cs.slice;

import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map.Entry;
import java.util.Set;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Multiset;

import edu.ucla.cs.model.Assignment;
import edu.ucla.cs.model.Method;
import edu.ucla.cs.model.Class;
import edu.ucla.cs.model.MethodCall;
import edu.ucla.cs.model.Receiver;
import edu.ucla.cs.process.lightweight.ArgumentProcessor;
import edu.ucla.cs.process.lightweight.AssignmentProcessor;
import edu.ucla.cs.process.lightweight.PredicateProcessor;
import edu.ucla.cs.process.lightweight.Process;
import edu.ucla.cs.process.lightweight.ReceiverProcessor;
import edu.ucla.cs.process.lightweight.SequenceProcessor;
import edu.ucla.cs.process.lightweight.TypeProcessor;

public class Slicer {
	final static String pattern = "IF \\{;\\};|ELSE \\{;\\};|LOOP \\{;\\};|TRY \\{;\\};(CATCH \\{;\\};)+(FINALLY \\{;\\};)*";

	public static HashMap<String, Method> methods = new HashMap<String, Method>();
	public static HashMap<String, Class> classes = new HashMap<String, Class>();

	/**
	 * Read BOA output data to build the method and class maps. Currently we
	 * handle five types of BOA outputs in the format of txt files. These BOA
	 * outputs are generated by our BOA scripts in CodeMiner. Names of these txt
	 * files are fixed for ease of processing.
	 */
	public static void setup() {
		Process proc = new Process();

		try {
			// process type info
			proc.s = new TypeProcessor();
			proc.processByLine("/home/troy/research/BOA/Maple/example/type.txt");

			// process api call sequences
			proc.s = new SequenceProcessor();
			proc.processByLine("/home/troy/research/BOA/Maple/example/sequence.txt");
			
			// process assignment
			proc.s = new AssignmentProcessor();
			proc.processByLine("/home/troy/research/BOA/Maple/example/assignment.txt");
			
			// process method call arguments
			proc.s = new ArgumentProcessor();
			proc.processByLine("/home/troy/research/BOA/Maple/example/argument.txt");
			
			// process method call receivers
			proc.s = new ReceiverProcessor();
			proc.processByLine("/home/troy/research/BOA/Maple/example/receiver.txt");

			// process method call predicates
			proc.s = new PredicateProcessor();
			proc.processByLine("/home/troy/research/BOA/Maple/example/predicate.txt");
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public static Multimap<String, String> slice(Set<String> api_query) {
		Multimap<String, String> res = ArrayListMultimap.create();

		for (Entry<String, Method> entry : methods.entrySet()) {
			String mkey = entry.getKey();
			Method m = entry.getValue();
			//Set<String> apis = old_fixpoint(m, api_query);
			// preprocess the api_query by adding prefix "m::"
			HashSet<String> query = new HashSet<String>();
			api_query.forEach(item -> query.add("m::" + item));
			Set<String> apis = fixpoint(m, query, new HashSet<String>());

			StringBuilder sb = new StringBuilder();
			for (String api : m.seq) {
				if (api.contains("{") || api.contains("}")) {
					// keep all blocks for now
					sb.append(api + ";");
				} else if (apis.contains(api)) {
					// keep the api call if it is relevant
					sb.append(api + ";");
				}
			}

			String s = sb.toString();
			while (true) {
				String temp = s.replaceAll(pattern, "");
				if (!temp.equals(s)) {
					s = temp;
				} else {
					// fix point
					s = temp;
					break;
				}
			}

			if (!s.isEmpty()) {
				String[] arr = s.split(";");
				for (String a : arr) {
					res.put(mkey, a);
				}
			}
		}

		return res;
	}

	private static Set<String> fixpoint(Method m, 
			Set<String> affected_elements,
			Set<String> consumed_elements) {
		Set<String> s1 = find_affected_elements(m, affected_elements);
		Set<String> s2 = find_consumed_elements(m, affected_elements);
		
		Set<String> s3 = find_consumed_elements(m, consumed_elements);
		
		Set<String> new_affected_elements = new HashSet<String>(affected_elements);
		new_affected_elements.addAll(s1);
		
		Set<String> new_consumed_elements = new HashSet<String>(consumed_elements);
		new_consumed_elements.addAll(s2);
		new_consumed_elements.addAll(s3);
		
		if(new_affected_elements.equals(affected_elements) && new_consumed_elements.equals(consumed_elements)) {
			// fix point
			Set<String> all = new HashSet<String>(affected_elements);
			all.addAll(consumed_elements);
			
			return return_apis_only(all);
		} else {
			return fixpoint(m, new_affected_elements, new_consumed_elements);
		}
	}
	
	private static Set<String> find_affected_elements(Method m, Set<String> set) {
		HashSet<String> res = new HashSet<String>();
		
 		for(String s : set) {
			// 1. Query the reverse assignment map to find all variables that the
			// values of affected variables and APIs flow to
			if(m.rev_assigns.containsKey(s)){
				Multiset<Assignment> assigns = m.rev_assigns.get(s);
				assigns.forEach(item -> res.add("v::" + item.lhs));
			}
			
			// 2. Query the reverse argument map to find all APIs that take any
			// affected variables or return values of affected APIs as argument
			if(m.rev_args.containsKey(s)){
				Multiset<MethodCall> args = m.rev_args.get(s);
				args.forEach(item -> res.add("m::" + item.name));
			}
			
			// 3. Query the receiver map to find all variables and APIs that each affected 
			// APIs calls on
			if(s.startsWith("m::") && m.receivers.containsKey(s.substring(3))) {
				Multiset<Receiver> rcvs = m.receivers.get(s.substring(3));
				rcvs.forEach(item -> res.add(item.obj));
			}
		}
		
		return res;
	}
	
	private static Set<String> find_consumed_elements(Method m, Set<String> set) {
		HashSet<String> res = new HashSet<String>();
		
		for(String s : set) {
			// 1. Query the assignment map to find all variables and APIs that are
			// assigned to the target variable
			if(s.startsWith("v::") && m.assigns.containsKey(s.substring(3))) {
				Multiset<Assignment> assigns = m.assigns.get(s.substring(3));
				for(Assignment a : assigns) {
					for(String rhs : a.rhs) {
						if(rhs.startsWith("v::") || rhs.startsWith("m::")) {
							// filter out the literals
							res.add(rhs);
						}
					}
				}
			}
			
			// 2. Query the argument map to find all variables and apis that each
			// target API uses as argument
			if(s.startsWith("m::") && m.args.containsKey(s.substring(3))) {
				Multiset<MethodCall> mcs = m.args.get(s.substring(3));
				for(MethodCall mc : mcs) {
					for(String arg : mc.args) {
						if(arg.startsWith("v::") || arg.startsWith("m::")) {
							// filter out literals
							res.add(arg);
						}
					}
				}
			}
			
			// 3. Query the reverse receiver map to find all APIs that each target 
			// variable calls on
			if(m.rev_receivers.containsKey(s)) {
				Multiset<Receiver> rcvs = m.rev_receivers.get(s);
				rcvs.forEach(item -> res.add("m::" + item.method));
			}
		}
		
		return res;
	}
	
	private static Set<String> return_apis_only(Set<String> set) {
		HashSet<String> apis = new HashSet<String>();
		for(String s : set) {
			if(s.startsWith("m::")){
				// remove the prefix and add to the return set
				apis.add(s.substring(3));
			}
		}
		
		return apis;
	}

	/* private static Set<String> old_fixpoint(Method m, Set<String> query) {
		HashSet<String> res = new HashSet<String>(query);

		if (m.file
				.equals("cube-android/src/com/foreveross/chameleon/pad/fragment/ChatRoomFragment.java")) {
			System.out.println("stop");
		}

		// fresh a temporary set to solve the concurrent modification exception
		// on Java collections
		Set<String> temp = new HashSet<String>();

		// 1. query the receiver map to find all variables that each API in the
		// query set calls on
		HashSet<String> vars = new HashSet<String>();
		for (String api : query) {
			if (m.receivers.containsKey(api)) {
				Multiset<Receiver> rset = m.receivers.get(api);
				for (Receiver r : rset) {
					vars.add(r.obj);
				}
			}
		}

		// 2. query the argument map to find all variables and apis that each
		// API in the query set uses as argument
		for (String api : query) {
			if (m.args.containsKey(api)) {
				Multiset<MethodCall> mcset = m.args.get(api);
				for (MethodCall mc : mcset) {
					for (String arg : mc.args) {
						if (arg.startsWith("v::")) {
							// variable
							String vname = arg
									.substring(arg.indexOf("v::") + 3);
							vars.add(vname);
						} else if (arg.startsWith("m::")) {
							// method
							String mname = arg
									.substring(arg.indexOf("m::") + 3);
							res.add(mname);
						}
					}
				}
			}
		}

		// 3. query the reverse argument map to find all APIs that take any
		// variable in vars or any API in query as argument
		for (String api : query) {
			if (m.rev_args.containsKey("m::" + api)) {
				Multiset<MethodCall> mcset = m.rev_args.get("m::" + api);
				for (MethodCall mc : mcset) {
					res.add(mc.name);
				}
			}
		}

		for (String var : vars) {
			if (m.rev_args.containsKey("v::" + var)) {
				Multiset<MethodCall> mcset = m.rev_args.get("v::" + var);
				for (MethodCall mc : mcset) {
					res.add(mc.name);
				}
			}
		}

		// 4. Query the reverse assignment map to find all variables that the
		// values of variables in vars and API calls in query flow to.
		for (String api : query) {
			if (m.rev_assigns.containsKey(api)) {
				Multiset<Assignment> aset = m.rev_assigns.get(api);
				for (Assignment a : aset) {
					vars.add(a.lhs);
				}
			}
		}

		for (String var : vars) {
			if (m.rev_assigns.containsKey(var)) {
				Multiset<Assignment> aset = m.rev_assigns.get(var);
				for (Assignment a : aset) {
					// stores it in a temporary set for now to avoid
					// concurrently modifying vars
					temp.add(a.lhs);
				}
			}
		}

		// flush elements in the temporary set to vars
		vars.addAll(temp);
		temp.clear();

		// 5. Query the assignment map to find all variables and APIs that are
		// assigned to each variable in vars
		for (String var : vars) {
			if (m.assigns.containsKey(var)) {
				Multiset<Assignment> aset = m.assigns.get(var);
				for (Assignment a : aset) {
					for (String s : a.rhs) {
						if (s.startsWith("v::")) {
							// variable
							String vname = s.substring(s.indexOf("v::") + 3);
							// stores it in a temporary set for now to avoid
							// concurrently modifying vars
							temp.add(vname);
						} else if (s.startsWith("m::")) {
							// method
							String mname = s.substring(s.indexOf("m::") + 3);
							res.add(mname);
						}
					}
				}
			}
		}
		// flush elements in the temporary set to vars
		vars.addAll(temp);
		temp.clear();

		// 6. Query the reverse receiver map to find all APIs in query that each
		// variable in vars calls.
		for (String var : vars) {
			if (m.rev_receivers.containsKey(var)) {
				Multiset<Receiver> rset = m.rev_receivers.get(var);
				for (Receiver r : rset) {
					res.add(r.method);
				}
			}
		}

		// keep calling itself until reaching a fix point
		if (res.equals(query)) {
			return res;
		} else {
			return old_fixpoint(m, res);
		}
	} */

	public static void main(String[] args) {
		Set<String> api_query = new HashSet<String>();
		api_query.add("createNewFile");

		Slicer.setup();
		Multimap<String, String> seqs = Slicer.slice(api_query);
		for (String s : seqs.keySet()) {
			System.out.println(s + "---" + seqs.get(s));
		}
	}
}
